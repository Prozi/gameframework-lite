<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">es2015/view.js | gameframework-lite</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="game framework for 2d html5 games with physics isomorphic"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="gameframework-lite"><meta property="twitter:description" content="game framework for 2d html5 games with physics isomorphic"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Prozi/gameframework-lite.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">es2015/view.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }

var _require = require(&apos;./index&apos;),
    Level = _require.Level;

var PIXI = typeof window !== &apos;undefined&apos; ? require(&apos;pixi.js&apos;) : {};

module.exports = function () {
	function View() {
		var screenSize = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : 480;
		var anchor = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : document.body;

		_classCallCheck(this, View);

		this.screenSize = screenSize;
		this.pixi = new PIXI.Application(window.innerWidth, window.innerHeight, {
			autoResize: false,
			roundPixels: true,
			clearBeforeRender: false,
			resolution: 1
		});
		this.camera = new PIXI.Container();
		this.pixi.stage.addChild(this.camera);
		this.level = new Level();
		this.level.onUpdateHero = this._onUpdateHero.bind(this);
		this.level.onCreateHero = this._onCreateHero.bind(this);
		this.level.onRemoveHero = this._onRemoveHero.bind(this);
		anchor.appendChild(this.pixi.view);
		window.addEventListener(&apos;resize&apos;, this.onResize.bind(this), true);
		this.onResize();
		this.pixi.start();
	}

	_createClass(View, [{
		key: &apos;cameraToHero&apos;,
		value: function cameraToHero(hero) {
			this.camera.x = Math.floor(-hero.sprite.x + window.innerWidth / 2 / this.scale);
			this.camera.y = Math.floor(-hero.sprite.y + window.innerHeight / 2 / this.scale);
		}
	}, {
		key: &apos;onUpdateHero&apos;,
		value: function onUpdateHero(hero) {
			// this is what you should override
		}
	}, {
		key: &apos;_onUpdateHero&apos;,
		value: function _onUpdateHero(hero) {
			this.onUpdateHero(hero);
			if (hero.sprite) {
				hero.sprite.x = hero.x * this.level.accuracy;
				hero.sprite.y = hero.y * this.level.accuracy;
			}
		}
		// this is what you should override

	}, {
		key: &apos;onCreateHero&apos;,
		value: function onCreateHero(hero) {
			hero.sprite = PIXI.Sprite.from(&apos;bunny.png&apos;);
			hero.sprite.anchor.set(0.5);
			hero.sprite.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
		}
	}, {
		key: &apos;_onCreateHero&apos;,
		value: function _onCreateHero(hero) {
			if (!hero.sprite) {
				this.onCreateHero(hero);
				if (hero.sprite) {
					hero.sprite.x = hero.x * this.level.accuracy;
					hero.sprite.y = hero.y * this.level.accuracy;
					(this.layers ? this.layers.heros : this.camera).addChild(hero.sprite);
				}
			}
		}
	}, {
		key: &apos;onRemoveHero&apos;,
		value: function onRemoveHero(hero) {
			// this is what you should override
		}
	}, {
		key: &apos;_onRemoveHero&apos;,
		value: function _onRemoveHero(hero) {
			this.onRemoveHero(hero);
			if (hero.sprite &amp;&amp; hero.sprite.parent) {
				hero.sprite.parent.removeChild(hero.sprite);
			}
		}
	}, {
		key: &apos;onResize&apos;,
		value: function onResize() {
			this.scale = this.getScale();
			this.pixi.renderer.resize(window.innerWidth, window.innerHeight);
			this.pixi.stage.scale.set(this.scale);
		}
	}, {
		key: &apos;getScale&apos;,
		value: function getScale() {
			return +(Math.sqrt(window.innerWidth * window.innerHeight) / this.screenSize).toFixed(2);
		}
	}, {
		key: &apos;getTexture&apos;,
		value: function getTexture(frame) {
			if (!this.textureCache[frame]) {
				// &lt;-- tiled firstgid === 1
				var size = this.level.tileset.tilewidth,
				    width = this.level.tileset.imagewidth / this.level.tileset.tilewidth,
				    x = (frame - 1) % width * size,
				    y = Math.floor((frame - 1) / width) * size;
				this.textureCache[frame] = new PIXI.Texture(this.tileset, new PIXI.Rectangle(x, y, size, size));
				this.textureCache[frame].baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
			}
			return this.textureCache[frame];
		}
	}, {
		key: &apos;createSprite&apos;,
		value: function createSprite(frame) {
			var nearest = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : PIXI.SCALE_MODES.NEAREST;

			var sprite = void 0;
			if (isFinite(frame)) {
				sprite = new PIXI.Sprite(this.getTexture(parseInt(frame, 10)));
			} else {
				sprite = PIXI.Sprite.from(frame);
			}
			sprite.texture.baseTexture.scaleMode = nearest;
			return sprite;
		}
	}, {
		key: &apos;addBlock&apos;,
		value: function addBlock(x, y, block) {
			var layer = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : this.layers.blocks;
			var nearest = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : PIXI.SCALE_MODES.NEAREST;

			var sprite = this.createSprite(block, nearest);
			sprite.width = sprite.height = this.level.tileset.tilewidth;
			sprite.x = Math.floor(this.level.tileset.tilewidth * x);
			sprite.y = Math.floor(this.level.tileset.tilewidth * y);
			sprite.anchor.set(0.5);
			layer.addChild(sprite);
		}
	}, {
		key: &apos;addBlocks&apos;,
		value: function addBlocks() {
			for (var y = 0; y &lt; this.level.height; y++) {
				for (var x = 0; x &lt; this.level.width; x++) {
					var block = this.level.blocks[x + &apos;:&apos; + y];
					if (block &amp;&amp; Array.isArray(block)) {
						for (var i = 0; i &lt; block.length; i++) {
							if (parseInt(block[i], 10)) {
								this.addBlock(x, y, block[i]);
							}
						}
					}
				}
			}
		}
	}, {
		key: &apos;createLevel&apos;,
		value: function createLevel(tiled) {
			this.textureCache = {};
			this.layers = {
				blocks: new PIXI.Container(),
				heros: new PIXI.Container()
			};
			this.tileset = PIXI.Texture.from(tiled.tilesets[0].image, false, PIXI.SCALE_MODES.NEAREST);
			this.camera.addChild(this.layers.blocks);
			this.camera.addChild(this.layers.heros);
			this.level.fromTiled(tiled);
			this.addBlocks();
		}
	}, {
		key: &apos;_onMouseMove&apos;,
		value: function _onMouseMove(event) {
			event.stopPropagation();
			var e = event.touches ? event.touches[0] : event;
			this.mouse = {
				x: e.clientX,
				y: e.clientY
			};
			if (this.onMouseMove) {
				this.onMouseMove();
			}
		}
	}, {
		key: &apos;_onMouseClick&apos;,
		value: function _onMouseClick(event) {
			this._onMouseMove(event);
			if (this.onMouseClick) {
				this.onMouseClick();
			}
		}
	}, {
		key: &apos;useMouse&apos;,
		value: function useMouse() {
			var disableContextMenu = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : false;

			window.addEventListener(&apos;touchmove&apos;, this._onMouseMove.bind(this), false);
			window.addEventListener(&apos;touchstart&apos;, this._onMouseClick.bind(this), false);
			window.addEventListener(&apos;mousemove&apos;, this._onMouseMove.bind(this), false);
			window.addEventListener(&apos;mousedown&apos;, this._onMouseClick.bind(this), false);
			if (disableContextMenu) {
				this.disableContextMenu();
			}
		}
	}, {
		key: &apos;disableContextMenu&apos;,
		value: function disableContextMenu() {
			document.body.addEventListener(&apos;contextmenu&apos;, function (event) {
				return event.preventDefault();
			}, false);
		}
	}, {
		key: &apos;hero&apos;,
		get: function get() {
			return this.level.heros[this.id];
		}
	}]);

	return View;
}();</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.3)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
